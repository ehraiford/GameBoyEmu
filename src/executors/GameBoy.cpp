#include "GameBoy.h"
#include "../memory/Cartridge.h"
#include "../memory/Memory.h"
#include "Cpu.h"
#include <cstring>

// This is the custom bootrom available at https://github.com/Hacktix/Bootix under the CC0-1.0 License.
//  This does not contain any copyrighted Nintendo data.
static constexpr std::array<uint8_t, 256> BOOTROM = {
	0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0x0C, 0x20, 0xFB, 0x0E, 0x11, 0x21, 0x26, 0xFF,
	0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0x32, 0xE2, 0x0C, 0x3E, 0x77, 0x32, 0xE2, 0x11, 0x04,
	0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0xB8, 0x00, 0x1A, 0xCB, 0x37, 0xCD, 0xB8, 0x00, 0x13, 0x7B,
	0xFE, 0x34, 0x20, 0xF0, 0x11, 0xCC, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
	0x21, 0x04, 0x99, 0x01, 0x0C, 0x01, 0xCD, 0xB1, 0x00, 0x3E, 0x19, 0x77, 0x21, 0x24, 0x99, 0x0E,
	0x0C, 0xCD, 0xB1, 0x00, 0x3E, 0x91, 0xE0, 0x40, 0x06, 0x10, 0x11, 0xD4, 0x00, 0x78, 0xE0, 0x43,
	0x05, 0x7B, 0xFE, 0xD8, 0x28, 0x04, 0x1A, 0xE0, 0x47, 0x13, 0x0E, 0x1C, 0xCD, 0xA7, 0x00, 0xAF,
	0x90, 0xE0, 0x43, 0x05, 0x0E, 0x1C, 0xCD, 0xA7, 0x00, 0xAF, 0xB0, 0x20, 0xE0, 0xE0, 0x43, 0x3E,
	0x83, 0xCD, 0x9F, 0x00, 0x0E, 0x27, 0xCD, 0xA7, 0x00, 0x3E, 0xC1, 0xCD, 0x9F, 0x00, 0x11, 0x8A,
	0x01, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x1B, 0x7A, 0xB3, 0x20, 0xF5, 0x18, 0x49, 0x0E, 0x13,
	0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xC9, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0xC9,
	0x78, 0x22, 0x04, 0x0D, 0x20, 0xFA, 0xC9, 0x47, 0x0E, 0x04, 0xAF, 0xC5, 0xCB, 0x10, 0x17, 0xC1,
	0xCB, 0x10, 0x17, 0x0D, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0x3C, 0x42, 0xB9, 0xA5, 0xB9,
	0xA5, 0x42, 0x3C, 0x00, 0x54, 0xA8, 0xFC, 0x42, 0x4F, 0x4F, 0x54, 0x49, 0x58, 0x2E, 0x44, 0x4D,
	0x47, 0x20, 0x76, 0x31, 0x2E, 0x32, 0x00, 0x3E, 0xFF, 0xC6, 0x01, 0x0B, 0x1E, 0xD8, 0x21, 0x4D,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x01, 0xE0, 0x50, 0xC9
};

void GameBoy::load_buffer_as_cartridge(std::vector<uint8_t> buffer) {
	this->cartridge.initialize_cartridge_from_data(buffer);
}
DataBus* GameBoy::get_databus() {
	return &this->data_bus;
}
void GameBoy::queue_event(GameBoyEvent event) {
	this->unprocessed_events.push(event);
}

void GameBoy::run_bootrom() {
	uint8_t cartridge_data[0x100];
	std::memcpy(cartridge_data, this->cartridge.get_rom()->get_memory_ptr(0x00), sizeof(cartridge_data));
	this->cartridge.get_rom()->load_data(std::vector<uint8_t>(BOOTROM.begin(), BOOTROM.end()));
	this->cpu.point_pc_at_start_of_memory();

	for (long long i = 0; i < 40000; i++) {
		this->tick_machine_cycle();
	}

	this->cartridge.get_rom()->load_data(std::vector<uint8_t>(cartridge_data, cartridge_data + sizeof(cartridge_data)));
}

void GameBoy::process_new_events() {
	while (!this->unprocessed_events.empty()) {
		GameBoyEvent event = this->unprocessed_events.front();
		this->unprocessed_events.pop();
		switch (event) {
		case OamDmaTransfer:
			// Handle OAM DMA transfer
			break;
		case Stop:
			// Handle Stop Event
			break;
		case Halt:
			// Handle Halt Event
			break;
		default:
			std::cout << "An Unknown Event made it to the CPU" << std::endl;
			break;
		}
	}
}

void GameBoy::display_tiles() {
	std::array<Tile, 384> tiles = this->ppu.get_tiles();
	for (int i = 0; i < 3; i++) {
		tiles[i].display();
	}
}

void GameBoy::tick_machine_cycle() {
	// this->process_new_events();
	this->cpu.tick_machine_cycle();
}